//
// OsrmRouteResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public struct OsrmRouteResponse: Codable, JSONEncodable, Hashable {
    public enum Code: String, Codable, CaseIterable {
        case ok = "Ok"
        case invalidUrl = "InvalidUrl"
        case invalidService = "InvalidService"
        case invalidVersion = "InvalidVersion"
        case invalidOptions = "InvalidOptions"
        case invalidQuery = "InvalidQuery"
        case invalidValue = "InvalidValue"
        case noSegment = "NoSegment"
        case tooBig = "TooBig"
        case noRoute = "NoRoute"
        case noTable = "NoTable"
        case notImplemented = "NotImplemented"
        case noTrips = "NoTrips"
    }

    public var code: Code
    public var message: String?
    public var dataVersion: String?
    public var waypoints: [OsrmWaypoint]?
    public var routes: [OsrmRoute]?

    public init(code: Code, message: String? = nil, dataVersion: String? = nil, waypoints: [OsrmWaypoint]? = nil, routes: [OsrmRoute]? = nil) {
        self.code = code
        self.message = message
        self.dataVersion = dataVersion
        self.waypoints = waypoints
        self.routes = routes
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case code
        case message
        case dataVersion = "data_version"
        case waypoints
        case routes
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(code, forKey: .code)
        try container.encodeIfPresent(message, forKey: .message)
        try container.encodeIfPresent(dataVersion, forKey: .dataVersion)
        try container.encodeIfPresent(waypoints, forKey: .waypoints)
        try container.encodeIfPresent(routes, forKey: .routes)
    }
}
