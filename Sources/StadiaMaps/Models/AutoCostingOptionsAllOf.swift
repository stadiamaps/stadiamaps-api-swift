//
// AutoCostingOptionsAllOf.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public struct AutoCostingOptionsAllOf: Codable, JSONEncodable, Hashable {
    static let useHighwaysRule = NumericRule<Double>(minimum: 0, exclusiveMinimum: false, maximum: 1, exclusiveMaximum: false, multipleOf: nil)
    static let useTollsRule = NumericRule<Double>(minimum: 0, exclusiveMinimum: false, maximum: 1, exclusiveMaximum: false, multipleOf: nil)
    static let useTracksRule = NumericRule<Double>(minimum: 0, exclusiveMinimum: false, maximum: 1, exclusiveMaximum: false, multipleOf: nil)
    static let topSpeedRule = NumericRule<Int>(minimum: 10, exclusiveMinimum: false, maximum: 252, exclusiveMaximum: false, multipleOf: nil)
    /** The height of the automobile (in meters). */
    public var height: Double? = 1.9
    /** The width of the automobile (in meters). */
    public var width: Double? = 1.6
    /** The estimated cost (in seconds) when a toll booth is encountered. */
    public var tollBoothCost: Int? = 15
    /** A penalty (in seconds) applied to the route cost when a toll booth is encountered. This penalty can be used to reduce the likelihood of suggesting a route with toll booths unless absolutely necessary. */
    public var tollBoothPenalty: Int? = 0
    /** The estimated cost (in seconds) when a ferry is encountered. */
    public var ferryCost: Int? = 300
    /** A measure of willingness to take highways. Values near 0 attempt to avoid highways, and values near 1 will favour them. Note that as some routes may be impossible without highways, 0 does not guarantee avoidance of them. */
    public var useHighways: Double? = 0.5
    /** A measure of willingness to take toll roads. Values near 0 attempt to avoid tolls, and values near 1 will favour them. Note that as some routes may be impossible without tolls, 0 does not guarantee avoidance of them. */
    public var useTolls: Double? = 0.5
    /** A measure of willingness to take track roads. Values near 0 attempt to avoid them, and values near 1 will favour them. Note that as some routes may be impossible without track roads, 0 does not guarantee avoidance of them. The default value is 0 for automobiles, busses, and trucks; and 0.5 for all other costing modes. */
    public var useTracks: Double?
    /** The top speed (in kph) that the vehicle is capable of travelling. */
    public var topSpeed: Int? = 140
    /** If true changes the cost metric to be quasi-shortest (pure distance-based) costing. This will disable ALL other costing factors. */
    public var shortest: Bool? = false
    /** If true, ignores all known closures. This option cannot be set if `location.search_filter.exclude_closures` is also specified. */
    public var ignoreClosures: Bool? = false
    /** If true, indicates the desire to include HOV roads with a 2-occupant requirement in the route when advantageous. */
    public var includeHov2: Bool? = false
    /** If true, indicates the desire to include HOV roads with a 3-occupant requirement in the route when advantageous. */
    public var includeHov3: Bool? = false
    /** If true, indicates the desire to include toll roads which require the driver to pay a toll if the occupant requirement isn't met */
    public var includeHot: Bool? = false

    public init(height: Double? = 1.9, width: Double? = 1.6, tollBoothCost: Int? = 15, tollBoothPenalty: Int? = 0, ferryCost: Int? = 300, useHighways: Double? = 0.5, useTolls: Double? = 0.5, useTracks: Double? = nil, topSpeed: Int? = 140, shortest: Bool? = false, ignoreClosures: Bool? = false, includeHov2: Bool? = false, includeHov3: Bool? = false, includeHot: Bool? = false) {
        self.height = height
        self.width = width
        self.tollBoothCost = tollBoothCost
        self.tollBoothPenalty = tollBoothPenalty
        self.ferryCost = ferryCost
        self.useHighways = useHighways
        self.useTolls = useTolls
        self.useTracks = useTracks
        self.topSpeed = topSpeed
        self.shortest = shortest
        self.ignoreClosures = ignoreClosures
        self.includeHov2 = includeHov2
        self.includeHov3 = includeHov3
        self.includeHot = includeHot
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case height
        case width
        case tollBoothCost = "toll_booth_cost"
        case tollBoothPenalty = "toll_booth_penalty"
        case ferryCost = "ferry_cost"
        case useHighways = "use_highways"
        case useTolls = "use_tolls"
        case useTracks = "use_tracks"
        case topSpeed = "top_speed"
        case shortest
        case ignoreClosures = "ignore_closures"
        case includeHov2 = "include_hov2"
        case includeHov3 = "include_hov3"
        case includeHot = "include_hot"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(height, forKey: .height)
        try container.encodeIfPresent(width, forKey: .width)
        try container.encodeIfPresent(tollBoothCost, forKey: .tollBoothCost)
        try container.encodeIfPresent(tollBoothPenalty, forKey: .tollBoothPenalty)
        try container.encodeIfPresent(ferryCost, forKey: .ferryCost)
        try container.encodeIfPresent(useHighways, forKey: .useHighways)
        try container.encodeIfPresent(useTolls, forKey: .useTolls)
        try container.encodeIfPresent(useTracks, forKey: .useTracks)
        try container.encodeIfPresent(topSpeed, forKey: .topSpeed)
        try container.encodeIfPresent(shortest, forKey: .shortest)
        try container.encodeIfPresent(ignoreClosures, forKey: .ignoreClosures)
        try container.encodeIfPresent(includeHov2, forKey: .includeHov2)
        try container.encodeIfPresent(includeHov3, forKey: .includeHov3)
        try container.encodeIfPresent(includeHot, forKey: .includeHot)
    }
}
