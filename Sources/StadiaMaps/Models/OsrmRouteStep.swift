//
// OsrmRouteStep.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

/** A maneuver such as a turn or merge, followed by travel along a single road or path. */
public struct OsrmRouteStep: Codable, JSONEncodable, Hashable {
    public enum DrivingSide: String, Codable, CaseIterable {
        case _left = "left"
        case _right = "right"
    }

    public enum SpeedLimitSign: String, Codable, CaseIterable {
        case mutcd
        case vienna
    }

    /** The distance traveled by the route, in meters. */
    public var distance: Double
    /** The estimated travel time, in number of seconds. */
    public var duration: Double
    /** An encoded polyline (https://developers.google.com/maps/documentation/utilities/polylinealgorithm) with 6 digits of decimal precision. */
    public var geometry: String
    public var weight: Double?
    /** The name of the segment (ex: road) being traversed */
    public var name: String?
    /** A reference number of code for the segment being traversed. */
    public var ref: String?
    /** Pronunciation of the name (if available). The format of this varies by implementation/vendor. */
    public var pronunciation: String?
    public var destinations: String?
    public var exits: String?
    /** The mode of travel. */
    public var mode: String
    public var maneuver: OsrmStepManeuver
    public var intersections: [OsrmIntersection]?
    /** The name of the traffic circle. */
    public var rotaryName: String?
    /** Pronunciation of the rotary name (if available). The format of this varies by implementation/vendor. */
    public var rotaryPronunciation: String?
    /** The side of the road on which driving is legal for this step. */
    public var drivingSide: DrivingSide?
    /** A list of announcements which should be spoken at various points along the maneuver. */
    public var voiceInstructions: [OsrmVoiceInstruction]?
    /** A list of announcements which should be displayed prominently on screen at various points along the maneuver. */
    public var bannerInstructions: [OsrmBannerInstruction]?
    /** The style of speed limit signs used along the step. */
    public var speedLimitSign: SpeedLimitSign?
    /** The unit of measure that is used locally along the step. This may be different from the unit used in maxspeed annotations, and is provided so that apps can localize their display. */
    public var speedLimitUnit: String?

    public init(distance: Double, duration: Double, geometry: String, weight: Double? = nil, name: String? = nil, ref: String? = nil, pronunciation: String? = nil, destinations: String? = nil, exits: String? = nil, mode: String, maneuver: OsrmStepManeuver, intersections: [OsrmIntersection]? = nil, rotaryName: String? = nil, rotaryPronunciation: String? = nil, drivingSide: DrivingSide? = nil, voiceInstructions: [OsrmVoiceInstruction]? = nil, bannerInstructions: [OsrmBannerInstruction]? = nil, speedLimitSign: SpeedLimitSign? = nil, speedLimitUnit: String? = nil) {
        self.distance = distance
        self.duration = duration
        self.geometry = geometry
        self.weight = weight
        self.name = name
        self.ref = ref
        self.pronunciation = pronunciation
        self.destinations = destinations
        self.exits = exits
        self.mode = mode
        self.maneuver = maneuver
        self.intersections = intersections
        self.rotaryName = rotaryName
        self.rotaryPronunciation = rotaryPronunciation
        self.drivingSide = drivingSide
        self.voiceInstructions = voiceInstructions
        self.bannerInstructions = bannerInstructions
        self.speedLimitSign = speedLimitSign
        self.speedLimitUnit = speedLimitUnit
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case distance
        case duration
        case geometry
        case weight
        case name
        case ref
        case pronunciation
        case destinations
        case exits
        case mode
        case maneuver
        case intersections
        case rotaryName = "rotary_name"
        case rotaryPronunciation = "rotary_pronunciation"
        case drivingSide = "driving_side"
        case voiceInstructions
        case bannerInstructions
        case speedLimitSign
        case speedLimitUnit
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(distance, forKey: .distance)
        try container.encode(duration, forKey: .duration)
        try container.encode(geometry, forKey: .geometry)
        try container.encodeIfPresent(weight, forKey: .weight)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(ref, forKey: .ref)
        try container.encodeIfPresent(pronunciation, forKey: .pronunciation)
        try container.encodeIfPresent(destinations, forKey: .destinations)
        try container.encodeIfPresent(exits, forKey: .exits)
        try container.encode(mode, forKey: .mode)
        try container.encode(maneuver, forKey: .maneuver)
        try container.encodeIfPresent(intersections, forKey: .intersections)
        try container.encodeIfPresent(rotaryName, forKey: .rotaryName)
        try container.encodeIfPresent(rotaryPronunciation, forKey: .rotaryPronunciation)
        try container.encodeIfPresent(drivingSide, forKey: .drivingSide)
        try container.encodeIfPresent(voiceInstructions, forKey: .voiceInstructions)
        try container.encodeIfPresent(bannerInstructions, forKey: .bannerInstructions)
        try container.encodeIfPresent(speedLimitSign, forKey: .speedLimitSign)
        try container.encodeIfPresent(speedLimitUnit, forKey: .speedLimitUnit)
    }
}
